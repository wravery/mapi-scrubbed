<#@ template language="C#" #>
<#@ output extension=".cpp" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ assembly name="System.Collections" #>
<#@ assembly name="System.Linq" #>
<#@ assembly name="System.Text.RegularExpressions" #>

#include <array>
#include <cstdint>
#include <iomanip>
#include <ios>
#include <iostream>
#include <string>
#include <string_view>

<#
	var headers = GetHeaders();

	foreach (var file in headers)
	{
#>#include "<#= file #>"
<#
	}
#>

void outputCode(std::string_view name, std::uint32_t code)
{
	std::cout << R"(

#ifdef )" << name << R"(
#undef )" << name << R"(
#define )" << name << R"( ((HRESULT)0x)"
		<< std::hex << std::setfill('0') << std::uppercase << std::setw(8)
		<< code << R"()
#endif // )" << name;
}

void outputConst(std::string_view name, auto value)
{
	constexpr auto width = sizeof(value) * 2;

	std::cout << R"(

#ifdef )" << name << R"(
#undef )" << name << R"(
#define )" << name << R"( (0x)"
		<< std::hex << std::setfill('0') << std::uppercase << std::setw(width)
		<< value << R"()
#endif // )" << name;
}

int main()
{
	using namespace std::literals;

	std::cout << R"(// Include all of the original MAPI headers. This file should be a drop-in replacement.

<#
	foreach (var file in headers)
	{
#>
#include "<#= file #>"
<#
	}
#>

// Redefine all of the macros we found in a simplified form that matches the regular expressions in
// https://github.com/microsoft/win32metadata. To keep C++ code in sync with the preprocessor flags
// used to generate this file, you should include this header instead of the original MAPI headers.)";

	constexpr std::array mapiCodeMacros {
<#
	var mapiCodeMacros = headers
		.Select(file => GetMapiCodeMacros(file))
		.Aggregate((first, second) => first.Concat(second))
		.Distinct();

	foreach (var macro in mapiCodeMacros)
	{
#>
		std::make_pair("<#= macro #>"sv, static_cast<std::uint32_t>(<#= macro #>)),
<#
	}
#>
	};

	for (const auto& entry : mapiCodeMacros)
	{
		outputCode(entry.first, entry.second);
	}

	constexpr std::array propTypeMacros {
<#
	var propTypeMacros = headers
		.Select(file => GetPropTypeMacros(file))
		.Aggregate((first, second) => first.Concat(second))
		.Distinct();

	foreach (var macro in propTypeMacros)
	{
#>
		std::make_pair("<#= macro #>"sv, static_cast<std::uint16_t>(<#= macro #>)),
<#
	}
#>
	};

	for (const auto& entry : propTypeMacros)
	{
		outputConst(entry.first, entry.second);
	}

	constexpr std::array propTagMacros {
<#
	var propTagMacros = headers
		.Select(file => GetPropTagMacros(file))
		.Aggregate((first, second) => first.Concat(second))
		.Distinct();

	foreach (var macro in propTagMacros)
	{
#>
		std::make_pair("<#= macro #>"sv, static_cast<std::uint32_t>(<#= macro #>)),
<#
	}
#>
	};

	for (const auto& entry : propTagMacros)
	{
		outputConst(entry.first, entry.second);
	}

	constexpr std::array otherLongMacros {
<#
	var propTypeMacrosSet = propTypeMacros.ToHashSet();
	var otherLongMacros = headers
		.Select(file => GetOtherLongMacros(file, propTypeMacrosSet))
		.Aggregate((first, second) => first.Concat(second))
		.Distinct();

	foreach (var macro in otherLongMacros)
	{
#>
		std::make_pair("<#= macro #>"sv, static_cast<std::uint32_t>(<#= macro #>)),
<#
	}
#>
	};

	for (const auto& entry : otherLongMacros)
	{
		outputConst(entry.first, entry.second);
	}

	std::cout << std::endl;

	return 0;
}

<#+
	private static string[] GetHeaders()
	{
		return Directory.EnumerateFiles("./", "*.h")
			.Select(file => Path.GetFileName(file))
			.ToArray();
	}

	private static IEnumerable<string> GetPropTagMacros(string file)
	{
		var missing = new HashSet<string> {
			@"PR_USER_SID",
			@"PR_DOTSTUFF_STATE",
			@"PR_CONVERSION_STATE",
			@"PR_HTML",
		};
		var pattern = new Regex(@"^\s*#define\s+([^(\s]+)\s+PROP_TAG\(.+,.+\)");
		var path = Path.Combine("./", file);
		return File.ReadAllLines(path)
			.Select(line => pattern.Match(line))
			.Where(match => match.Success)
			.Select(match => match.Groups[1].Value)
			.Where(macro => !missing.Contains(macro));
	}

	private static IEnumerable<string> GetMapiCodeMacros(string file)
	{
		var pattern = new Regex(@"^\s*#define\s+([^(\s]+)\s+MAKE_MAPI_[ES]\(.+\)");
		var path = Path.Combine("./", file);
		return File.ReadAllLines(path)
			.Select(line => pattern.Match(line))
			.Where(match => match.Success)
			.Select(match => match.Groups[1].Value);
	}

	private static IEnumerable<string> GetPropTypeMacros(string file)
	{
		var pattern = new Regex(@"^\s*#define\s+(PT_[^(\s]+)\s+\(.+\)");
		var path = Path.Combine("./", file);
		return File.ReadAllLines(path)
			.Select(line => pattern.Match(line))
			.Where(match => match.Success)
			.Select(match => match.Groups[1].Value);
	}

	private static IEnumerable<string> GetOtherLongMacros(string file, HashSet<string> propTypeMacros)
	{
		var pattern = new Regex(@"^\s*#define\s+([^(\s]+)\s+\(\s*\((:?U?LONG|BOOKMARK)\).+\)");
		var path = Path.Combine("./", file);
		return File.ReadAllLines(path)
			.Select(line => pattern.Match(line))
			.Where(match => match.Success)
			.Select(match => match.Groups[1].Value)
			.Where(macro => !propTypeMacros.Contains(macro));
	}
#>