<#@ template language="C#" #>
<#@ output extension=".cpp" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ assembly name="System.Collections" #>
<#@ assembly name="System.Linq" #>
<#@ assembly name="System.Text.RegularExpressions" #>

#include <array>
#include <cstdint>
#include <iomanip>
#include <ios>
#include <iostream>
#include <string>
#include <string_view>

<#
	var headers = GetHeaders();

	foreach (var file in headers)
	{
#>#include "<#= file #>"
<#
	}
#>

int main()
{
	using namespace std::literals;

	std::cout << R"(<#
	foreach (var file in headers)
	{
#>
#include "<#= file #>"
<#
	}
#>
)";

	constexpr std::array mapiCodeMacros {
<#
	var mapiCodeMacros = headers
		.Select(file => GetMapiCodeMacros(file))
		.Aggregate((first, second) => first.Concat(second))
		.Distinct();

	foreach (var macro in mapiCodeMacros)
	{
#>
		std::make_pair("<#= macro #>"sv, static_cast<std::uint32_t>(<#= macro #>)),
<#
	}
#>
	};

	for (const auto& entry : mapiCodeMacros)
	{
		std::cout << R"(
#ifdef )" << entry.first << R"(
#undef )" << entry.first << R"(
#define )" << entry.first << R"( ((HRESULT)0x)"
			<< std::hex << std::setfill('0') << std::uppercase << std::setw(8)
			<< entry.second << R"()
#endif // )" << entry.first << R"(
)";
	}

	constexpr std::array propTypeMacros {
<#
	var propTypeMacros = headers
		.Select(file => GetPropTypeMacros(file))
		.Aggregate((first, second) => first.Concat(second))
		.Distinct();

	foreach (var macro in propTypeMacros)
	{
#>
		std::make_pair("<#= macro #>"sv, static_cast<std::uint16_t>(<#= macro #>)),
<#
	}
#>
	};

	for (const auto& entry : propTypeMacros)
	{
		std::cout << R"(
#ifdef )" << entry.first << R"(
#undef )" << entry.first << R"(
#define )" << entry.first << R"( (0x)"
			<< std::hex << std::setfill('0') << std::uppercase << std::setw(4)
			<< entry.second << R"()
#endif // )" << entry.first << R"(
)";
	}

	constexpr std::array propTagMacros {
<#
	var propTagMacros = headers
		.Select(file => GetPropTagMacros(file))
		.Aggregate((first, second) => first.Concat(second))
		.Distinct();

	foreach (var macro in propTagMacros)
	{
#>
		std::make_pair("<#= macro #>"sv, static_cast<std::uint32_t>(<#= macro #>)),
<#
	}
#>
	};

	for (const auto& entry : propTagMacros)
	{
		std::cout << R"(
#ifdef )" << entry.first << R"(
#undef )" << entry.first << R"(
#define )" << entry.first << R"( (0x)"
			<< std::hex << std::setfill('0') << std::uppercase << std::setw(8)
			<< entry.second << R"()
#endif // )" << entry.first << R"(
)";
	}

	constexpr std::array otherLongMacros {
<#
	var propTypeMacrosSet = propTypeMacros.ToHashSet();
	var otherLongMacros = headers
		.Select(file => GetOtherLongMacros(file, propTypeMacrosSet))
		.Aggregate((first, second) => first.Concat(second))
		.Distinct();

	foreach (var macro in otherLongMacros)
	{
#>
		std::make_pair("<#= macro #>"sv, static_cast<std::uint32_t>(<#= macro #>)),
<#
	}
#>
	};

	for (const auto& entry : otherLongMacros)
	{
		std::cout << R"(
#ifdef )" << entry.first << R"(
#undef )" << entry.first << R"(
#define )" << entry.first << R"( (0x)"
			<< std::hex << std::setfill('0') << std::uppercase << std::setw(8)
			<< entry.second << R"()
#endif // )" << entry.first << R"(
)";
	}

	std::cout << std::endl;

	return 0;
}

<#+
	private static string[] GetHeaders()
	{
		return Directory.EnumerateFiles("../include/", "*.h")
			.Select(file => Path.GetFileName(file))
			.ToArray();
	}

	private static IEnumerable<string> GetPropTagMacros(string file)
	{
		var missing = new HashSet<string> {
			@"PR_USER_SID",
			@"PR_DOTSTUFF_STATE",
			@"PR_CONVERSION_STATE",
			@"PR_HTML",
		};
		var pattern = new Regex(@"^\s*#define\s+([^(\s]+)\s+PROP_TAG\(.+,.+\)");
		var path = Path.Combine("../include/", file);
		return File.ReadAllLines(path)
			.Select(line => pattern.Match(line))
			.Where(match => match.Success)
			.Select(match => match.Groups[1].Value)
			.Where(macro => !missing.Contains(macro));
	}

	private static IEnumerable<string> GetMapiCodeMacros(string file)
	{
		var pattern = new Regex(@"^\s*#define\s+([^(\s]+)\s+MAKE_MAPI_[ES]\(.+\)");
		var path = Path.Combine("../include/", file);
		return File.ReadAllLines(path)
			.Select(line => pattern.Match(line))
			.Where(match => match.Success)
			.Select(match => match.Groups[1].Value);
	}

	private static IEnumerable<string> GetPropTypeMacros(string file)
	{
		var pattern = new Regex(@"^\s*#define\s+(PT_[^(\s]+)\s+\(.+\)");
		var path = Path.Combine("../include/", file);
		return File.ReadAllLines(path)
			.Select(line => pattern.Match(line))
			.Where(match => match.Success)
			.Select(match => match.Groups[1].Value);
	}

	private static IEnumerable<string> GetOtherLongMacros(string file, HashSet<string> propTypeMacros)
	{
		var pattern = new Regex(@"^\s*#define\s+([^(\s]+)\s+\(\s*\(U?LONG\).+\)");
		var path = Path.Combine("../include/", file);
		return File.ReadAllLines(path)
			.Select(line => pattern.Match(line))
			.Where(match => match.Success)
			.Select(match => match.Groups[1].Value)
			.Where(macro => !propTypeMacros.Contains(macro));
	}
#>